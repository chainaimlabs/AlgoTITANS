#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock 0x151f7c75 "blCounter" "totalValueLocked" "BL "
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txn NumAppArgs
    bz main_bare_routing@12
    pushbytess 0x02bece11 0x7d01fd23 0x9bd01310 0x04b313dc 0xf1b940a9 0xe9baec2b 0x0494f90f // method "hello(string)string", method "createFinancialBL(string,uint64,uint64,uint64,uint64,uint64,string,string,string,string,string,string)string", method "getBLFinancialInfo(string)string", method "verifyCompliance(string,string)string", method "tokenizeForTrading(string,uint64)string", method "calculateYield(string,uint64)uint64", method "getCounters()string"
    txna ApplicationArgs 0
    match main_hello_route@3 main_createFinancialBL_route@4 main_getBLFinancialInfo_route@5 main_verifyCompliance_route@6 main_tokenizeForTrading_route@7 main_calculateYield_route@8 main_getCounters_route@9

main_after_if_else@16:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    intc_0 // 0
    return

main_getCounters_route@9:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:83
    // getCounters(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getCounters
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_calculateYield_route@8:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:75
    // calculateYield(blId: string, investmentAmount: uint64): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:75
    // calculateYield(blId: string, investmentAmount: uint64): uint64 {
    callsub calculateYield
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_tokenizeForTrading_route@7:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:68
    // tokenizeForTrading(blId: string, fractionalShares: uint64): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:68
    // tokenizeForTrading(blId: string, fractionalShares: uint64): string {
    callsub tokenizeForTrading
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_verifyCompliance_route@6:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:61
    // verifyCompliance(blId: string, regulatoryHash: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:61
    // verifyCompliance(blId: string, regulatoryHash: string): string {
    callsub verifyCompliance
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getBLFinancialInfo_route@5:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:54
    // getBLFinancialInfo(blId: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:54
    // getBLFinancialInfo(blId: string): string {
    callsub getBLFinancialInfo
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_createFinancialBL_route@4:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:18-31
    // createFinancialBL(
    //   description: string,
    //   cargoValue: uint64,
    //   blType: uint64,
    //   creditRating: uint64,
    //   riskScore: uint64,
    //   yieldRate: uint64,
    //   vleiID: string,
    //   jurisdictionCode: string,
    //   complianceHash: string,
    //   incoterms: string,
    //   insurancePolicyID: string,
    //   lcrReference: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    extract 2 0
    txna ApplicationArgs 8
    extract 2 0
    txna ApplicationArgs 9
    extract 2 0
    txna ApplicationArgs 10
    extract 2 0
    txna ApplicationArgs 11
    extract 2 0
    txna ApplicationArgs 12
    extract 2 0
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:18-31
    // createFinancialBL(
    //   description: string,
    //   cargoValue: uint64,
    //   blType: uint64,
    //   creditRating: uint64,
    //   riskScore: uint64,
    //   yieldRate: uint64,
    //   vleiID: string,
    //   jurisdictionCode: string,
    //   complianceHash: string,
    //   incoterms: string,
    //   insurancePolicyID: string,
    //   lcrReference: string
    // ): string {
    callsub createFinancialBL
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_hello_route@3:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:11
    // hello(name: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:11
    // hello(name: string): string {
    callsub hello
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@12:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:3
    // export class NegotiableFinBLV1 extends Contract {
    txn OnCompletion
    bnz main_after_if_else@16
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/negotiable_fin_bl_v1/contract.algo.ts::NegotiableFinBLV1.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:11
    // hello(name: string): string {
    proto 1 1
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:12
    // return `Hello from FinBLV1, ${name}`
    pushbytes "Hello from FinBLV1, "
    frame_dig -1
    concat
    retsub


// smart_contracts/negotiable_fin_bl_v1/contract.algo.ts::NegotiableFinBLV1.createFinancialBL(description: bytes, cargoValue: uint64, blType: uint64, creditRating: uint64, riskScore: uint64, yieldRate: uint64, vleiID: bytes, jurisdictionCode: bytes, complianceHash: bytes, incoterms: bytes, insurancePolicyID: bytes, lcrReference: bytes) -> bytes:
createFinancialBL:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:18-31
    // createFinancialBL(
    //   description: string,
    //   cargoValue: uint64,
    //   blType: uint64,
    //   creditRating: uint64,
    //   riskScore: uint64,
    //   yieldRate: uint64,
    //   vleiID: string,
    //   jurisdictionCode: string,
    //   complianceHash: string,
    //   incoterms: string,
    //   insurancePolicyID: string,
    //   lcrReference: string
    // ): string {
    proto 12 1
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:5
    // blCounter = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "blCounter"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:34
    // if (!this.blCounter.hasValue) {
    app_global_get_ex
    bury 1
    bnz createFinancialBL_after_if_else@2
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:5
    // blCounter = GlobalState<uint64>()
    bytec_1 // "blCounter"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:35
    // this.blCounter.value = 0
    intc_0 // 0
    app_global_put

createFinancialBL_after_if_else@2:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:6
    // totalValueLocked = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalValueLocked"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:38
    // if (!this.totalValueLocked.hasValue) {
    app_global_get_ex
    bury 1
    bnz createFinancialBL_after_if_else@4
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:6
    // totalValueLocked = GlobalState<uint64>()
    bytec_2 // "totalValueLocked"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:39
    // this.totalValueLocked.value = 0
    intc_0 // 0
    app_global_put

createFinancialBL_after_if_else@4:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:5
    // blCounter = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "blCounter"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:43
    // this.blCounter.value = this.blCounter.value + 1
    intc_1 // 1
    +
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:5
    // blCounter = GlobalState<uint64>()
    bytec_1 // "blCounter"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:43
    // this.blCounter.value = this.blCounter.value + 1
    swap
    app_global_put
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:6
    // totalValueLocked = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalValueLocked"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:46
    // this.totalValueLocked.value = this.totalValueLocked.value + cargoValue
    frame_dig -11
    +
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:6
    // totalValueLocked = GlobalState<uint64>()
    bytec_2 // "totalValueLocked"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:46
    // this.totalValueLocked.value = this.totalValueLocked.value + cargoValue
    swap
    app_global_put
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:48
    // return `Created Financial BL for ${description}`
    pushbytes "Created Financial BL for "
    frame_dig -12
    concat
    retsub


// smart_contracts/negotiable_fin_bl_v1/contract.algo.ts::NegotiableFinBLV1.getBLFinancialInfo(blId: bytes) -> bytes:
getBLFinancialInfo:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:54
    // getBLFinancialInfo(blId: string): string {
    proto 1 1
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:55
    // return `FinBL ${blId}: Financial info available`
    pushbytes "FinBL "
    frame_dig -1
    concat
    pushbytes ": Financial info available"
    concat
    retsub


// smart_contracts/negotiable_fin_bl_v1/contract.algo.ts::NegotiableFinBLV1.verifyCompliance(blId: bytes, regulatoryHash: bytes) -> bytes:
verifyCompliance:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:61
    // verifyCompliance(blId: string, regulatoryHash: string): string {
    proto 2 1
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:62
    // return `BL ${blId} compliance verified`
    bytec_3 // "BL "
    frame_dig -2
    concat
    pushbytes " compliance verified"
    concat
    retsub


// smart_contracts/negotiable_fin_bl_v1/contract.algo.ts::NegotiableFinBLV1.tokenizeForTrading(blId: bytes, fractionalShares: uint64) -> bytes:
tokenizeForTrading:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:68
    // tokenizeForTrading(blId: string, fractionalShares: uint64): string {
    proto 2 1
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:69
    // return `BL ${blId} tokenized for trading`
    bytec_3 // "BL "
    frame_dig -2
    concat
    pushbytes " tokenized for trading"
    concat
    retsub


// smart_contracts/negotiable_fin_bl_v1/contract.algo.ts::NegotiableFinBLV1.calculateYield(blId: bytes, investmentAmount: uint64) -> uint64:
calculateYield:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:75
    // calculateYield(blId: string, investmentAmount: uint64): uint64 {
    proto 2 1
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:77
    // return investmentAmount / 20
    frame_dig -1
    pushint 20 // 20
    /
    retsub


// smart_contracts/negotiable_fin_bl_v1/contract.algo.ts::NegotiableFinBLV1.getCounters() -> bytes:
getCounters:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:5
    // blCounter = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "blCounter"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:84
    // const count: uint64 = this.blCounter.hasValue ? this.blCounter.value : 0
    app_global_get_ex
    bury 1
    bz getCounters_ternary_merge@3
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:5
    // blCounter = GlobalState<uint64>()
    intc_0 // 0
    bytec_1 // "blCounter"
    app_global_get_ex
    bury 1
    assert // check GlobalState exists

getCounters_ternary_merge@3:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:6
    // totalValueLocked = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalValueLocked"
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:85
    // const tvl: uint64 = this.totalValueLocked.hasValue ? this.totalValueLocked.value : 0
    app_global_get_ex
    bury 1
    bz getCounters_ternary_merge@6
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:6
    // totalValueLocked = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalValueLocked"
    app_global_get_ex
    bury 1
    assert // check GlobalState exists

getCounters_ternary_merge@6:
    // smart_contracts/negotiable_fin_bl_v1/contract.algo.ts:86
    // return `Counters available`
    pushbytes "Counters available"
    retsub
