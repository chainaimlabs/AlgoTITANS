#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 100 640
    bytecblock 0x00 0x151f7c75 "nextListingId" "listings" "nextSaleId" "totalVolume" "totalFees" "marketplaceFeeRate" "usdcAssetId" "active" "sales"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txn NumAppArgs
    bz main_bare_routing@13
    pushbytess 0xea7167c2 0x994973c3 0x5e47ecd3 0xf7549a52 0xaaff10e1 0x4e74e4d3 0x1c394d68 0x0cd1842e // method "initialize(uint64)bool", method "listInstrument(uint64,uint64,uint64,uint64)uint64", method "purchaseWithAlgo(uint64,pay)bool", method "purchaseWithUSDC(uint64,axfer)bool", method "cancelListing(uint64)bool", method "getListing(uint64)(uint64,uint64,address,uint64,uint64,uint64,uint64,bool,uint64)", method "getSale(uint64)(uint64,uint64,address,address,uint64,uint64,uint64)", method "getMarketplaceStats()(uint64,uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match main_initialize_route@3 main_listInstrument_route@4 main_purchaseWithAlgo_route@5 main_purchaseWithUSDC_route@6 main_cancelListing_route@7 main_getListing_route@8 main_getSale_route@9 main_getMarketplaceStats_route@10

main_after_if_else@17:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    intc_0 // 0
    return

main_getMarketplaceStats_route@10:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:322
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getMarketplaceStats
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getSale_route@9:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:313
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:313
    // @abimethod({ readonly: true })
    callsub getSale
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getListing_route@8:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:304
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:304
    // @abimethod({ readonly: true })
    callsub getListing
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_cancelListing_route@7:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:282
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:282
    // @abimethod()
    callsub cancelListing
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_purchaseWithUSDC_route@6:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:164
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:164
    // @abimethod()
    callsub purchaseWithUSDC
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_purchaseWithAlgo_route@5:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:132
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:132
    // @abimethod()
    callsub purchaseWithAlgo
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_listInstrument_route@4:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:88
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:88
    // @abimethod()
    callsub listInstrument
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initialize_route@3:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:71
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:71
    // @abimethod()
    callsub initialize
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@13:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:50
    // export default class AtomicMarketplaceV3 extends Contract {
    txn OnCompletion
    bnz main_after_if_else@17
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.initialize(usdcAssetId: uint64) -> uint64:
initialize:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:71-72
    // @abimethod()
    // public initialize(usdcAssetId: uint64): boolean {
    proto 1 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:73
    // assert(Txn.sender === Global.creatorAddress, 'Only creator can initialize')
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:61
    // public nextListingId = GlobalState<uint64>()
    bytec_2 // "nextListingId"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:75
    // this.nextListingId.value = 1
    intc_1 // 1
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:62
    // public nextSaleId = GlobalState<uint64>()
    bytec 4 // "nextSaleId"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:76
    // this.nextSaleId.value = 1
    intc_1 // 1
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:63
    // public totalVolume = GlobalState<uint64>()
    bytec 5 // "totalVolume"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:77
    // this.totalVolume.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:64
    // public totalFees = GlobalState<uint64>()
    bytec 6 // "totalFees"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:78
    // this.totalFees.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:65
    // public marketplaceFeeRate = GlobalState<uint64>()
    bytec 7 // "marketplaceFeeRate"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:79
    // this.marketplaceFeeRate.value = 100 // 1%
    intc_3 // 100
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:66
    // public usdcAssetId = GlobalState<uint64>()
    bytec 8 // "usdcAssetId"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:80
    // this.usdcAssetId.value = usdcAssetId
    frame_dig -1
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:82
    // return true
    intc_1 // 1
    retsub


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.listInstrument(instrumentId: uint64, askPriceAlgo: uint64, askPriceUSDC: uint64, validityPeriod: uint64) -> uint64:
listInstrument:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:88-94
    // @abimethod()
    // public listInstrument(
    //   instrumentId: uint64,
    //   askPriceAlgo: uint64,
    //   askPriceUSDC: uint64,
    //   validityPeriod: uint64
    // ): uint64 {
    proto 4 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:61
    // public nextListingId = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "nextListingId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:96
    // if (this.nextListingId.value === 0) {
    bnz listInstrument_after_if_else@2
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:61
    // public nextListingId = GlobalState<uint64>()
    bytec_2 // "nextListingId"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:97
    // this.nextListingId.value = 1
    intc_1 // 1
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:62
    // public nextSaleId = GlobalState<uint64>()
    bytec 4 // "nextSaleId"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:98
    // this.nextSaleId.value = 1
    intc_1 // 1
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:63
    // public totalVolume = GlobalState<uint64>()
    bytec 5 // "totalVolume"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:99
    // this.totalVolume.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:64
    // public totalFees = GlobalState<uint64>()
    bytec 6 // "totalFees"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:100
    // this.totalFees.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:65
    // public marketplaceFeeRate = GlobalState<uint64>()
    bytec 7 // "marketplaceFeeRate"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:101
    // this.marketplaceFeeRate.value = 100 // 1%
    intc_3 // 100
    app_global_put

listInstrument_after_if_else@2:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:105
    // assert(askPriceAlgo > 0 || askPriceUSDC > 0, 'Must set price in at least one currency')
    frame_dig -3
    bnz listInstrument_bool_true@4
    frame_dig -2
    bz listInstrument_bool_false@5

listInstrument_bool_true@4:
    intc_1 // 1

listInstrument_bool_merge@6:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:105
    // assert(askPriceAlgo > 0 || askPriceUSDC > 0, 'Must set price in at least one currency')
    assert // Must set price in at least one currency
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:61
    // public nextListingId = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "nextListingId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:110
    // listingId: new arc4.UintN64(listingId),
    dup
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:111
    // instrumentId: new arc4.UintN64(instrumentId),
    frame_dig -4
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:112
    // seller: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:113
    // askPriceAlgo: new arc4.UintN64(askPriceAlgo),
    frame_dig -3
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:114
    // askPriceUSDC: new arc4.UintN64(askPriceUSDC),
    frame_dig -2
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:115
    // listingTime: new arc4.UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:116
    // validUntil: new arc4.UintN64(Global.latestTimestamp + validityPeriod),
    global LatestTimestamp
    frame_dig -1
    +
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:65
    // public marketplaceFeeRate = GlobalState<uint64>()
    intc_0 // 0
    bytec 7 // "marketplaceFeeRate"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:118
    // marketplaceFee: new arc4.UintN64(this.marketplaceFeeRate.value)
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:109-119
    // const listing = new InstrumentListing({
    //   listingId: new arc4.UintN64(listingId),
    //   instrumentId: new arc4.UintN64(instrumentId),
    //   seller: new arc4.Address(Txn.sender),
    //   askPriceAlgo: new arc4.UintN64(askPriceAlgo),
    //   askPriceUSDC: new arc4.UintN64(askPriceUSDC),
    //   listingTime: new arc4.UintN64(Global.latestTimestamp),
    //   validUntil: new arc4.UintN64(Global.latestTimestamp + validityPeriod),
    //   isActive: new arc4.Bool(true),
    //   marketplaceFee: new arc4.UintN64(this.marketplaceFeeRate.value)
    // })
    dig 7
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:117
    // isActive: new arc4.Bool(true),
    pushbytes 0x80
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:109-119
    // const listing = new InstrumentListing({
    //   listingId: new arc4.UintN64(listingId),
    //   instrumentId: new arc4.UintN64(instrumentId),
    //   seller: new arc4.Address(Txn.sender),
    //   askPriceAlgo: new arc4.UintN64(askPriceAlgo),
    //   askPriceUSDC: new arc4.UintN64(askPriceUSDC),
    //   listingTime: new arc4.UintN64(Global.latestTimestamp),
    //   validUntil: new arc4.UintN64(Global.latestTimestamp + validityPeriod),
    //   isActive: new arc4.Bool(true),
    //   marketplaceFee: new arc4.UintN64(this.marketplaceFeeRate.value)
    // })
    concat
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:54
    // public listings = BoxMap<uint64, InstrumentListing>({ keyPrefix: 'listings' })
    bytec_3 // "listings"
    dig 2
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:122
    // this.listings(listingId).value = listing.copy()
    swap
    box_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:56
    // public activeListings = BoxMap<uint64, arc4.Bool>({ keyPrefix: 'active' })
    bytec 9 // "active"
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:123
    // this.activeListings(listingId).value = new arc4.Bool(true)
    pushbytes 0x80
    box_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:124
    // this.nextListingId.value = listingId + 1
    dup
    intc_1 // 1
    +
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:61
    // public nextListingId = GlobalState<uint64>()
    bytec_2 // "nextListingId"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:124
    // this.nextListingId.value = listingId + 1
    swap
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:126
    // return listingId
    retsub

listInstrument_bool_false@5:
    intc_0 // 0
    b listInstrument_bool_merge@6


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.purchaseWithAlgo(listingId: uint64, payment: uint64) -> uint64:
purchaseWithAlgo:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:132-136
    // @abimethod()
    // public purchaseWithAlgo(
    //   listingId: uint64,
    //   payment: gtxn.PaymentTxn
    // ): boolean {
    proto 2 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:137
    // assert(this.listings(listingId).exists, 'Listing not found')
    frame_dig -2
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:54
    // public listings = BoxMap<uint64, InstrumentListing>({ keyPrefix: 'listings' })
    bytec_3 // "listings"
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:137
    // assert(this.listings(listingId).exists, 'Listing not found')
    dup
    box_len
    bury 1
    assert // Listing not found
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:138
    // const listing = this.listings(listingId).value.copy()
    box_get
    assert // Box must have value
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:141
    // assert(listing.isActive.native === true, 'Listing inactive')
    dup
    intc 4 // 640
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    intc_1 // 1
    ==
    assert // Listing inactive
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:142
    // assert(listing.validUntil.native > Global.latestTimestamp, 'Listing expired')
    dup
    pushint 72 // 72
    extract_uint64
    global LatestTimestamp
    >
    assert // Listing expired
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:143
    // assert(listing.askPriceAlgo.native > 0, 'ALGO not accepted for this listing')
    dup
    pushint 48 // 48
    extract_uint64
    dup
    assert // ALGO not accepted for this listing
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:146
    // assert(payment.amount === listing.askPriceAlgo.native, 'Incorrect payment amount')
    frame_dig -1
    gtxns Amount
    dup
    uncover 2
    ==
    assert // Incorrect payment amount
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:147
    // assert(payment.receiver === Global.currentApplicationAddress, 'Payment to wrong address')
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment to wrong address
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:148
    // assert(payment.sender === Txn.sender, 'Payment sender mismatch')
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender mismatch
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:153
    // Txn.sender.bytes,
    txn Sender
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:151-156
    // this.executeAtomicSettlement(
    //   listing,
    //   Txn.sender.bytes,
    //   payment.amount,
    //   1 // ALGO currency
    // )
    swap
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:155
    // 1 // ALGO currency
    intc_1 // 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:151-156
    // this.executeAtomicSettlement(
    //   listing,
    //   Txn.sender.bytes,
    //   payment.amount,
    //   1 // ALGO currency
    // )
    callsub executeAtomicSettlement
    pop
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:158
    // return true
    intc_1 // 1
    retsub


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.purchaseWithUSDC(listingId: uint64, payment: uint64) -> uint64:
purchaseWithUSDC:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:164-168
    // @abimethod()
    // public purchaseWithUSDC(
    //   listingId: uint64,
    //   payment: gtxn.AssetTransferTxn
    // ): boolean {
    proto 2 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:169
    // assert(this.listings(listingId).exists, 'Listing not found')
    frame_dig -2
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:54
    // public listings = BoxMap<uint64, InstrumentListing>({ keyPrefix: 'listings' })
    bytec_3 // "listings"
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:169
    // assert(this.listings(listingId).exists, 'Listing not found')
    dup
    box_len
    bury 1
    assert // Listing not found
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:170
    // const listing = this.listings(listingId).value.copy()
    box_get
    assert // Box must have value
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:173
    // assert(listing.isActive.native === true, 'Listing inactive')
    dup
    intc 4 // 640
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    intc_1 // 1
    ==
    assert // Listing inactive
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:174
    // assert(listing.validUntil.native > Global.latestTimestamp, 'Listing expired')
    dup
    pushint 72 // 72
    extract_uint64
    global LatestTimestamp
    >
    assert // Listing expired
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:175
    // assert(listing.askPriceUSDC.native > 0, 'USDC not accepted for this listing')
    dup
    pushint 56 // 56
    extract_uint64
    dup
    assert // USDC not accepted for this listing
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:178
    // assert(payment.assetAmount === listing.askPriceUSDC.native, 'Incorrect payment amount')
    frame_dig -1
    gtxns AssetAmount
    dup
    uncover 2
    ==
    assert // Incorrect payment amount
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:179
    // assert(payment.assetReceiver === Global.currentApplicationAddress, 'Payment to wrong address')
    frame_dig -1
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Payment to wrong address
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:180
    // assert(payment.sender === Txn.sender, 'Payment sender mismatch')
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender mismatch
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:181
    // assert(payment.xferAsset.id === this.usdcAssetId.value, 'Must pay with USDC')
    frame_dig -1
    gtxns XferAsset
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:66
    // public usdcAssetId = GlobalState<uint64>()
    intc_0 // 0
    bytec 8 // "usdcAssetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:181
    // assert(payment.xferAsset.id === this.usdcAssetId.value, 'Must pay with USDC')
    ==
    assert // Must pay with USDC
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:186
    // Txn.sender.bytes,
    txn Sender
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:184-189
    // this.executeAtomicSettlement(
    //   listing,
    //   Txn.sender.bytes,
    //   payment.assetAmount,
    //   2 // USDC currency
    // )
    swap
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:188
    // 2 // USDC currency
    pushint 2 // 2
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:184-189
    // this.executeAtomicSettlement(
    //   listing,
    //   Txn.sender.bytes,
    //   payment.assetAmount,
    //   2 // USDC currency
    // )
    callsub executeAtomicSettlement
    pop
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:191
    // return true
    intc_1 // 1
    retsub


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.executeAtomicSettlement(listing: bytes, buyer: bytes, totalAmount: uint64, currency: uint64) -> bytes:
executeAtomicSettlement:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:197-202
    // private executeAtomicSettlement(
    //   listing: InstrumentListing,
    //   buyer: bytes,
    //   totalAmount: uint64,
    //   currency: uint64
    // ) {
    proto 4 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:204
    // const marketplaceFee: uint64 = totalAmount / 100 // 1% fee
    frame_dig -2
    intc_3 // 100
    /
    dup
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:205
    // const sellerAmount: uint64 = totalAmount - marketplaceFee
    frame_dig -2
    swap
    -
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:207
    // if (currency === 1) { // ALGO
    frame_dig -1
    intc_1 // 1
    ==
    bz executeAtomicSettlement_else_body@3
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:209-215
    // itxn
    //   .payment({
    //     amount: sellerAmount,
    //     receiver: listing.seller.bytes,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:212
    // receiver: listing.seller.bytes,
    frame_dig -4
    extract 16 32 // on error: Index access is out of bounds
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:209-214
    // itxn
    //   .payment({
    //     amount: sellerAmount,
    //     receiver: listing.seller.bytes,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:213
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:209-215
    // itxn
    //   .payment({
    //     amount: sellerAmount,
    //     receiver: listing.seller.bytes,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

executeAtomicSettlement_after_if_else@5:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:229-236
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(listing.instrumentId.native),
    //     assetReceiver: buyer,
    //     assetAmount: 1,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:231
    // xferAsset: Asset(listing.instrumentId.native),
    frame_dig -4
    extract 8 8 // on error: Index access is out of bounds
    frame_dig -4
    pushint 8 // 8
    extract_uint64
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:233
    // assetAmount: 1,
    intc_1 // 1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:229-235
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(listing.instrumentId.native),
    //     assetReceiver: buyer,
    //     assetAmount: 1,
    //     fee: 0,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:234
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:229-236
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(listing.instrumentId.native),
    //     assetReceiver: buyer,
    //     assetAmount: 1,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:62
    // public nextSaleId = GlobalState<uint64>()
    intc_0 // 0
    bytec 4 // "nextSaleId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:265
    // saleId: new arc4.UintN64(saleId),
    dup
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:267
    // seller: listing.seller,
    frame_dig -4
    extract 16 32 // on error: Index access is out of bounds
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:269
    // salePrice: new arc4.UintN64(salePrice),
    frame_dig -2
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:270
    // currency: new arc4.UintN64(currency),
    frame_dig -1
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:271
    // saleTime: new arc4.UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:264-272
    // const sale = new InstrumentSale({
    //   saleId: new arc4.UintN64(saleId),
    //   instrumentId: listing.instrumentId,
    //   seller: listing.seller,
    //   buyer: new arc4.Address(buyer),
    //   salePrice: new arc4.UintN64(salePrice),
    //   currency: new arc4.UintN64(currency),
    //   saleTime: new arc4.UintN64(Global.latestTimestamp)
    // })
    dig 4
    dig 7
    concat
    dig 4
    concat
    frame_dig -3
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:55
    // public sales = BoxMap<uint64, InstrumentSale>({ keyPrefix: 'sales' })
    bytec 10 // "sales"
    uncover 3
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:275
    // this.sales(saleId).value = sale.copy()
    swap
    box_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:276
    // this.nextSaleId.value = saleId + 1
    swap
    intc_1 // 1
    +
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:62
    // public nextSaleId = GlobalState<uint64>()
    bytec 4 // "nextSaleId"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:276
    // this.nextSaleId.value = saleId + 1
    swap
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:242-245
    // this.listings(listing.listingId.native).value = new InstrumentListing({
    //   ...listing,
    //   isActive: new arc4.Bool(false)
    // })
    frame_dig -4
    extract 0 8 // on error: Index access is out of bounds
    frame_dig -4
    extract 48 8 // on error: Index access is out of bounds
    frame_dig -4
    extract 56 8 // on error: Index access is out of bounds
    frame_dig -4
    extract 64 8 // on error: Index access is out of bounds
    frame_dig -4
    extract 72 8 // on error: Index access is out of bounds
    frame_dig -4
    extract 81 8 // on error: Index access is out of bounds
    uncover 5
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:244
    // isActive: new arc4.Bool(false)
    bytec_0 // 0x00
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:242-245
    // this.listings(listing.listingId.native).value = new InstrumentListing({
    //   ...listing,
    //   isActive: new arc4.Bool(false)
    // })
    concat
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:242
    // this.listings(listing.listingId.native).value = new InstrumentListing({
    frame_dig -4
    intc_0 // 0
    extract_uint64
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:54
    // public listings = BoxMap<uint64, InstrumentListing>({ keyPrefix: 'listings' })
    bytec_3 // "listings"
    dig 1
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:242-245
    // this.listings(listing.listingId.native).value = new InstrumentListing({
    //   ...listing,
    //   isActive: new arc4.Bool(false)
    // })
    uncover 2
    box_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:56
    // public activeListings = BoxMap<uint64, arc4.Bool>({ keyPrefix: 'active' })
    bytec 9 // "active"
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:246
    // this.activeListings(listing.listingId.native).value = new arc4.Bool(false)
    bytec_0 // 0x00
    box_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:63
    // public totalVolume = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalVolume"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:249
    // this.totalVolume.value = this.totalVolume.value + totalAmount
    frame_dig -2
    +
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:63
    // public totalVolume = GlobalState<uint64>()
    bytec 5 // "totalVolume"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:249
    // this.totalVolume.value = this.totalVolume.value + totalAmount
    swap
    app_global_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:64
    // public totalFees = GlobalState<uint64>()
    intc_0 // 0
    bytec 6 // "totalFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:250
    // this.totalFees.value = this.totalFees.value + marketplaceFee
    frame_dig 0
    +
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:64
    // public totalFees = GlobalState<uint64>()
    bytec 6 // "totalFees"
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:250
    // this.totalFees.value = this.totalFees.value + marketplaceFee
    swap
    app_global_put
    frame_dig -4
    swap
    retsub

executeAtomicSettlement_else_body@3:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:218-225
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(this.usdcAssetId.value),
    //     assetReceiver: listing.seller.bytes,
    //     assetAmount: sellerAmount,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:66
    // public usdcAssetId = GlobalState<uint64>()
    intc_0 // 0
    bytec 8 // "usdcAssetId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:221
    // assetReceiver: listing.seller.bytes,
    frame_dig -4
    extract 16 32 // on error: Index access is out of bounds
    uncover 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:218-224
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(this.usdcAssetId.value),
    //     assetReceiver: listing.seller.bytes,
    //     assetAmount: sellerAmount,
    //     fee: 0,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:223
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:218-225
    // itxn
    //   .assetTransfer({
    //     xferAsset: Asset(this.usdcAssetId.value),
    //     assetReceiver: listing.seller.bytes,
    //     assetAmount: sellerAmount,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    b executeAtomicSettlement_after_if_else@5


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.cancelListing(listingId: uint64) -> uint64:
cancelListing:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:282-283
    // @abimethod()
    // public cancelListing(listingId: uint64): boolean {
    proto 1 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:284
    // assert(this.listings(listingId).exists, 'Listing not found')
    frame_dig -1
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:54
    // public listings = BoxMap<uint64, InstrumentListing>({ keyPrefix: 'listings' })
    bytec_3 // "listings"
    dig 1
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:284
    // assert(this.listings(listingId).exists, 'Listing not found')
    dup
    box_len
    bury 1
    assert // Listing not found
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:285
    // const listing = this.listings(listingId).value.copy()
    dup
    box_get
    assert // Box must have value
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:288
    // assert(listing.seller.bytes === Txn.sender.bytes, 'Only seller can cancel')
    dup
    extract 16 32 // on error: Index access is out of bounds
    dup
    txn Sender
    ==
    assert // Only seller can cancel
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:289
    // assert(listing.isActive.native === true, 'Listing already inactive')
    dig 1
    intc 4 // 640
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    intc_1 // 1
    ==
    assert // Listing already inactive
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:292-295
    // this.listings(listingId).value = new InstrumentListing({
    //   ...listing,
    //   isActive: new arc4.Bool(false)
    // })
    dig 1
    extract 0 8 // on error: Index access is out of bounds
    dig 2
    extract 8 8 // on error: Index access is out of bounds
    dig 3
    extract 48 8 // on error: Index access is out of bounds
    dig 4
    extract 56 8 // on error: Index access is out of bounds
    dig 5
    extract 64 8 // on error: Index access is out of bounds
    dig 6
    extract 72 8 // on error: Index access is out of bounds
    uncover 7
    extract 81 8 // on error: Index access is out of bounds
    uncover 6
    uncover 6
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:294
    // isActive: new arc4.Bool(false)
    bytec_0 // 0x00
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:292-295
    // this.listings(listingId).value = new InstrumentListing({
    //   ...listing,
    //   isActive: new arc4.Bool(false)
    // })
    concat
    swap
    concat
    box_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:56
    // public activeListings = BoxMap<uint64, arc4.Bool>({ keyPrefix: 'active' })
    bytec 9 // "active"
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:296
    // this.activeListings(listingId).value = new arc4.Bool(false)
    bytec_0 // 0x00
    box_put
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:298
    // return true
    intc_1 // 1
    retsub


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.getListing(listingId: uint64) -> bytes:
getListing:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:304-305
    // @abimethod({ readonly: true })
    // public getListing(listingId: uint64): InstrumentListing {
    proto 1 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:306
    // assert(this.listings(listingId).exists, 'Listing not found')
    frame_dig -1
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:54
    // public listings = BoxMap<uint64, InstrumentListing>({ keyPrefix: 'listings' })
    bytec_3 // "listings"
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:306
    // assert(this.listings(listingId).exists, 'Listing not found')
    dup
    box_len
    bury 1
    assert // Listing not found
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:307
    // return this.listings(listingId).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.getSale(saleId: uint64) -> bytes:
getSale:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:313-314
    // @abimethod({ readonly: true })
    // public getSale(saleId: uint64): InstrumentSale {
    proto 1 1
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:315
    // assert(this.sales(saleId).exists, 'Sale not found')
    frame_dig -1
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:55
    // public sales = BoxMap<uint64, InstrumentSale>({ keyPrefix: 'sales' })
    bytec 10 // "sales"
    swap
    concat
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:315
    // assert(this.sales(saleId).exists, 'Sale not found')
    dup
    box_len
    bury 1
    assert // Sale not found
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:316
    // return this.sales(saleId).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts::AtomicMarketplaceV3.getMarketplaceStats() -> bytes, bytes, bytes, bytes:
getMarketplaceStats:
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:63
    // public totalVolume = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalVolume"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:325
    // new arc4.UintN64(this.totalVolume.value),
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:64
    // public totalFees = GlobalState<uint64>()
    intc_0 // 0
    bytec 6 // "totalFees"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:326
    // new arc4.UintN64(this.totalFees.value),
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:61
    // public nextListingId = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "nextListingId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:327
    // new arc4.UintN64(this.nextListingId.value - 1),
    intc_1 // 1
    -
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:62
    // public nextSaleId = GlobalState<uint64>()
    intc_0 // 0
    bytec 4 // "nextSaleId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:328
    // new arc4.UintN64(this.nextSaleId.value - 1)
    intc_1 // 1
    -
    itob
    // smart_contracts/atomic_marketplace_v3/AtomicMarketplaceV3.algo.ts:324-329
    // return [
    //   new arc4.UintN64(this.totalVolume.value),
    //   new arc4.UintN64(this.totalFees.value),
    //   new arc4.UintN64(this.nextListingId.value - 1),
    //   new arc4.UintN64(this.nextSaleId.value - 1)
    // ]
    retsub
